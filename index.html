  <!-- CSV 파서를 위해 PapaParse 로드 -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <script>
    // 1) CSV를 fetch + 파싱
    async function loadCSV(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to fetch " + url);
      const text = await res.text();
      return new Promise((resolve) => {
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true, // 숫자 자동 변환
          complete: (result) => resolve(result.data),
        });
      });
    }

    // 2) market.csv -> {ticker: {date:[], close:[]}} 형태로 변환
    function buildMarketSeries(rows) {
      // 날짜 문자열을 그대로 x축으로 써도 되지만, 정렬 보장을 위해 정렬
      rows.sort((a, b) => (a.date < b.date ? -1 : a.date > b.date ? 1 : 0));
      const byTicker = {};
      for (const r of rows) {
        if (!r.ticker || r.close == null) continue;
        if (!byTicker[r.ticker]) byTicker[r.ticker] = { date: [], close: [] };
        byTicker[r.ticker].date.push(r.date);
        byTicker[r.ticker].close.push(r.close);
      }
      return byTicker;
    }

    // 3) future.csv -> 히트맵용 {tickers, dates, values}로 변환
    //    - 첫 컬럼: "Ticker"
    //    - 나머지 컬럼명: "YYYY-MM-DD" 날짜들
    function buildFutureMatrix(rows) {
      if (!rows.length) return { tickers: [], dates: [], values: [] };

      // PapaParse header:true 이므로 rows[0]의 키를 보면 열 이름을 알 수 있음
      const allCols = Object.keys(rows[0]);
      const dateCols = allCols.filter((c) => c !== "Ticker");

      // tickers, values
      const tickers = rows.map((r) => r["Ticker"]);
      const values = rows.map((r) => dateCols.map((d) => r[d]));

      return { tickers, dates: dateCols, values };
    }

    // 4) Plotly 그리기
    function renderTimeSeries(byTicker) {
      const traces = Object.entries(byTicker).map(([ticker, s]) => ({
        x: s.date,
        y: s.close,
        type: "scatter",
        mode: "lines",
        name: ticker,
      }));

      Plotly.newPlot(
        "timeseries",
        traces,
        {
          margin: { t: 20, r: 10, b: 40, l: 45 },
          xaxis: { title: "Date" },
          yaxis: { title: "Close" },
        },
        { responsive: true }
      );
    }

    function renderHeatmap(futureData) {
      Plotly.newPlot(
        "heatmap",
        [
          {
            type: "heatmap",
            z: futureData.values,
            x: futureData.dates,
            y: futureData.tickers,
            colorbar: { title: "Price" },
          },
        ],
        {
          margin: { t: 20, r: 10, b: 40, l: 90 },
          xaxis: { automargin: true },
          yaxis: { automargin: true },
        },
        { responsive: true }
      );
    }

    // 5) 실행: /data/market.csv, /data/future.csv 읽어서 렌더
    (async function main() {
      try {
        const [marketRows, futureRows] = await Promise.all([
          loadCSV("data/market.csv"),
          loadCSV("data/future.csv"),
        ]);

        const byTicker = buildMarketSeries(marketRows);
        renderTimeSeries(byTicker);

        const futureData = buildFutureMatrix(futureRows);
        renderHeatmap(futureData);
      } catch (e) {
        console.error(e);
        const err = document.createElement("div");
        err.style.color = "crimson";
        err.style.marginTop = "12px";
        err.textContent = "데이터를 불러오는 중 오류가 발생했습니다: " + e.message;
        document.body.appendChild(err);
      }
    })();
  </script>